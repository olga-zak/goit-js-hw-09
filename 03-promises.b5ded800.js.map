{"mappings":"iiBAAA,IAAAA,EAAAC,EAAA,SAMMC,EAAUC,SAASC,cAAc,QAEjCC,EAAiB,GAoCvB,SAASC,EAAcC,EAAUC,GAC/B,IAAMC,EAAgBC,KAAKC,SAAW,GAUtC,OARgB,IAAIC,SAAQ,SAACC,EAASC,GACpCC,YAAW,WACLN,GACFI,EAAQ,CAAEN,WAAUC,UAEYM,EAA3B,CAAEP,WAAUC,S,GAClBA,E,IA3CPN,EAAQc,iBAAiB,SAAS,SAAAC,GAGhCZ,EAAeY,EAAMC,OAAOC,MAAQF,EAAMC,OAAOE,K,IAOHlB,EAAxCc,iBAAiB,UAEzB,SAAsBC,GACpBA,EAAMI,iBAGN,IAFA,IAAIC,EAAW,EACXC,EAAQC,OAAOnB,EAAeG,OACzBiB,EAAI,EAAGA,GAAKpB,EAAeqB,OAAQD,GAAK,EAC/CnB,EAAcgB,EAAUC,GACrBI,MAAK,SAAAC,G,IAAGrB,EAAQqB,EAARrB,SAAUC,EAAKoB,EAALpB,MACjBqB,EAAA7B,GAAS8B,OAAOC,QACd,uBAAwCC,OAAfzB,EAAS,QAAYyB,OAANxB,EAAM,M,IAGjDyB,OAAM,SAAAL,G,IAAGrB,EAAQqB,EAARrB,SAAUC,EAAKoB,EAALpB,MAClBqB,EAAA7B,GAAS8B,OAAOI,QACd,sBAAuCF,OAAfzB,EAAS,QAAYyB,OAANxB,EAAM,M,IAGnDc,GAAY,EACZC,GAASC,OAAOnB,EAAe8B,MAEjClB,EAAMC,OAAOkB,O","sources":["src/js/03-promises.js"],"sourcesContent":["'use strict';\n\nimport Notiflix from 'notiflix';\n// генератор промисов\n// В HTML есть разметка формы, в поля которой пользователь будет вводить первую задержку в миллисекундах,\n// шаг увеличения задержки для каждого промиса после первого и количество промисов которое необходимо создать.\nconst formRef = document.querySelector('form');\n\nconst dataFromInputs = {};\n\nformRef.addEventListener('input', event => {\n  //console.log(event.target.name); // delay,step or amount\n  //console.log(event.target.value); // data that user has filled\n  dataFromInputs[event.target.name] = event.target.value;\n  // console.log(dataFromInputs);\n});\n\n// Напиши скрипт, который при сабмите формы вызывает функцию createPromise(position, delay) столько раз,\n// сколько ввели в поле amount.При каждом вызове передай ей номер создаваемого промиса(position) и задержку\n// учитывая введенную пользователем первую задержку(delay) и шаг(step).\nformRef.addEventListener('submit', onFormSubmit);\n\nfunction onFormSubmit(event) {\n  event.preventDefault();\n  let position = 1;\n  let delay = Number(dataFromInputs.delay);\n  for (let i = 1; i <= dataFromInputs.amount; i += 1) {\n    createPromise(position, delay)\n      .then(({ position, delay }) => {\n        Notiflix.Notify.success(\n          `✅ Fulfilled promise ${position} in ${delay}ms`\n        );\n      })\n      .catch(({ position, delay }) => {\n        Notiflix.Notify.failure(\n          `❌ Rejected promise ${position} in ${delay}ms`\n        );\n      });\n    position += 1;\n    delay += Number(dataFromInputs.step);\n  }\n  event.target.reset();\n}\n\nfunction createPromise(position, delay) {\n  const shouldResolve = Math.random() > 0.3;\n\n  const promise = new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (shouldResolve) {\n        resolve({ position, delay }); //значение усп.промиса { position, delay } будет параметром в callback1\n      }\n      reject({ position, delay }); //значение НЕусп.промиса { position, delay } будет параметром в callback2\n    }, delay);\n  });\n  return promise;\n}\n\n// Дополни код функции createPromise так, чтобы она возвращала один промис, который выполянется или отклоняется через delay времени.\n// Значением промиса должен быть объект, в котором будут свойства position и delay со значениями одноименных параметров.\n// Используй начальный код функции для выбора того, что нужно сделать с промисом - выполнить или отклонить.\n\n// Библиотека уведомлений\n// ВНИМАНИЕ\n// Этот функционал не обязателен при сдаче задания, но будет хорошей дополнительной практикой.\n\n// Для отображения уведомлений пользователю вместо console.log() используй библиотеку notiflix.\n\n// //THEORY\n// // 1.создали промис\n// const promise = new Promise((resolve, reject) => {\n//   const shouldResolve = Math.random() > 0.5;\n//   setTimeout(() => {\n//     if (shouldResolve) {\n//       resolve('it is ok'); //то что передаём в resolve, подёт параметром result в 1ый callback (в планировке ниже - пункт 2-2а)\n//     }\n\n//     reject('error mzfk'); //то что передаём в reject, подёт параметром error в 2ой callback (в планировке ниже - пункт 2-2б)\n//   }, 2000);\n// });\n\n// console.log(promise); //promise в состоянии pending\n\n// // 2.делаем планировку\n// promise.then(\n//   // 2а. если успешно, то делаем это\n//   result => {\n//     console.log(promise); //promise в состоянии fullfilled\n//     console.log(result);\n//   },\n//   // 2б. если НЕуспешно, то делаем это\n//   error => {\n//     console.log(promise); //promise в состоянии rejected\n//     console.log(error);\n//   }\n// );\n// // если промис выполнится успешно(или неуспешно), тогда (.then) сделай то, то в скобках после then - передаём туда callbackи -\n// // 1ый для успешного промиса, 2ой - для неуспешного (promise.then(callback1, callback2))\n// // then выполнится не сразу, а асинхронно - тогда, когда promise выполнится через 2000(задержка у таймаута)\n"],"names":["$iU1Pc","parcelRequire","$ce04d3a99e08e73b$var$formRef","document","querySelector","$ce04d3a99e08e73b$var$dataFromInputs","$ce04d3a99e08e73b$var$createPromise","position","delay","shouldResolve","Math","random","Promise","resolve","reject","setTimeout","addEventListener","event","target","name","value","preventDefault","position1","delay1","Number","i","amount","then","param","$parcel$interopDefault","Notify","success","concat","catch","failure","step","reset"],"version":3,"file":"03-promises.b5ded800.js.map"}